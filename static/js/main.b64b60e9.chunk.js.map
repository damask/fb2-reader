{"version":3,"sources":["db.js","constants/inboxListItems.jsx","fb2Parser.js","events.js","components/BookImporter.js","components/BookList.js","components/Reader.js","App.js","serviceWorker.js","index.js"],"names":["db","key","primaryText","leftIcon","active","openedDb","openDB","upgrade","createObjectStore","keyPath","autoIncrement","createIndex","bookExists","book","count","hashHex","addSection","section","add","addElement","element","getAllBooks","getAll","then","x","Fb2Parser","xml","this","ordinal","parentSectionId","title","querySelector","image","elements","querySelectorAll","parent","textContent","href","id","tagName","parseSection","tag","content","innerHTML","sectionId","e","bookId","body","sections","window","crypto","subtle","digest","TextEncoder","encode","hash","buffer","Array","prototype","map","call","Uint8Array","toString","slice","join","parser","DOMParser","doc","parseFromString","description","author","annotation","imageInfo","imageHref","getAttribute","test","imageBinary","type","dispatch","detail","document","dispatchEvent","CustomEvent","on","types","do","subscription","forEach","addEventListener","BookImporter","fileInput","React","createRef","floating","primary","style","height","width","padding","onClick","current","click","onChange","event","file","target","files","reader","FileReader","a","result","parseDescription","isAlreadyAdded","Events","parseBody","console","error","readAsText","ref","BookList","props","useState","books","setBooks","setBook","useEffect","className","subtitle","avatar","src","role","expander","flat","expandable","expanded","history","push","readBook","Reader","match","params","topSection","setTopSection","get","getBook","getFromIndex","getRootSection","align","alt","createBrowserHistory","App","addToast","text","action","autohide","setState","state","toasts","dismissToast","setPage","page","navItems","item","divider","hide","visible","renderNode","handleShow","getElementById","inboxListItems","toUpperCase","basename","aria-label","fullPage","focusOnMount","onShow","onHide","mobileDrawerType","NavigationDrawer","DrawerTypes","TEMPORARY_MINI","tabletDrawerType","PERSISTENT_MINI","desktopDrawerType","toolbarTitle","toolbarActions","icon","contentId","temporaryIcon","persistentIcon","contentClassName","path","component","from","to","onDismiss","autohideTimeout","PureComponent","Boolean","location","hostname","WebFontLoader","load","google","families","ReactDOM","render","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"6JAMIA,E,uGCHW,GAAC,CACdC,IAAK,QACLC,YAAa,QACbC,SAAU,kBAAC,IAAD,aACVC,QAAQ,GACP,CACDH,IAAK,OACLC,YAAa,OACbC,SAAU,kBAAC,IAAD,oBACV,CACAF,IAAK,SACLC,YAAa,SACbC,SAAU,kBAAC,IAAD,gBACT,CACDF,IAAK,QACLC,YAAa,QACbC,SAAU,kBAAC,IAAD,iB,wCDXNE,EAAWC,YAAO,aAAc,EAAG,CACrCC,QADqC,SAC7BP,GAEUA,EAAGQ,kBATX,QASoC,CACtCC,QAAS,UAAWC,eAAe,IAEjCC,YAAY,SAAU,UAEXX,EAAGQ,kBAbX,WAauC,CAC5CC,QAAS,KAAMC,eAAe,IAEzBC,YAAY,SAAU,UAEdX,EAAGQ,kBAjBX,WAiBuC,CAC5CC,QAAS,CAAC,YAAa,aAElBE,YAAY,YAAa,gBAWnC,SAASC,EAAWC,GACvB,OAAOb,EAAGc,MAlCA,QAkCaD,EAAKE,SAGzB,SAASC,EAAWC,GACvB,OAAOjB,EAAGkB,IArCG,WAqCWD,GAGrB,SAASE,EAAWC,GACvB,OAAOpB,EAAGkB,IAxCG,WAwCWE,GAGrB,SAASC,IACZ,OAAIrB,EACOA,EAAGsB,OA/CJ,SAiDHjB,EAASkB,MAAK,kBAAMvB,EAAGsB,OAjDpB,YA2BdjB,EAASkB,MAAK,SAAAC,GAAC,OAAIxB,EAAKwB,K,YEvBjB,IAAMC,EAAb,WAMI,WAAYC,GAAM,oBACbC,KAAKD,IAAMA,EACXC,KAAKC,QAAU,EARxB,kGAWuBX,EAASY,GAXhC,8FAccC,EAAQb,EAAQc,cAAc,SAC9BC,EAAQf,EAAQc,cAAc,SAC9BE,EAAWhB,EAAQiB,iBAAiB,cAhBlD,SAkByBlB,EAAW,CAACmB,OAAQN,EAAiBD,QAASD,KAAKC,UAChEE,MAAK,iBAAEA,QAAF,IAAEA,OAAF,EAAEA,EAAOM,mBAAT,QAAwB,KAAMJ,MAAK,iBAAEA,QAAF,IAAEA,OAAF,EAAEA,EAAOK,YAAT,QAAiB,OAnBrE,OAkBcC,EAlBd,qBAqB8BL,GArB9B,4DAsBoC,aADjBb,EArBnB,SAsBwBmB,QAtBxB,kCAuBsBZ,KAAKa,aAAapB,EAASkB,GAvBjD,iDAyBsBnB,EAAW,CACbsB,IAAKrB,EAAQmB,QACbG,QAAStB,EAAQuB,UACjBC,UAAWN,EACXV,QAASD,KAAKC,YA7BlC,mFAAAiB,EAAA,iWFyBwBhC,EEWac,KAAKd,KFV/Bb,EAAGkB,IA9BA,QA8BWL,GE1BzB,cAoCciC,EApCd,OAuCcC,EAAOpB,KAAKoB,KAEZjB,EAAQiB,EAAKhB,cAAc,SAC3BC,EAAQe,EAAKhB,cAAc,SAC3BiB,EAAWD,EAAKb,iBAAiB,oBA3C/C,SA6CyBlB,EAAW,CAACc,MAAK,iBAAEA,QAAF,IAAEA,OAAF,EAAEA,EAAOM,mBAAT,QAAwB,KAAMJ,MAAK,iBAAEA,QAAF,IAAEA,OAAF,EAAEA,EAAOK,YAAT,QAAiB,KAClFT,QAASD,KAAKC,UAAWO,OAAQW,IA9C7C,OA6CcR,EA7Cd,qBA+C8BU,GA/C9B,kEA+CmB/B,EA/CnB,kBAgDkBU,KAAKa,aAAavB,EAASqB,GAhD7C,qFAAAO,EAAA,oFFyBO,IAAiBhC,IEzBxB,uRAqD2BoC,OAAOC,OAAOC,OAAOC,OAAO,UAAW,IAAIC,YAAY,SAASC,OAAO3B,KAAKD,MArDvG,cAqDc6B,EArDd,OAJiBC,EA0DeD,EAAlBxC,EAzDH0C,MAAMC,UAAUC,IAAIC,KAAK,IAAIC,WAAWL,IAAS,SAAAhC,GAAC,OAAK,KAAOA,EAAEsC,SAAS,KAAKC,OAAO,MAAIC,KAAK,IA2D3FC,EAAS,IAAIC,UACbC,EAAMF,EAAOG,gBAAgBzC,KAAKD,IAAK,mBACvC2C,EAAcF,EAAIpC,cAAc,eAEhCuC,EAASD,EAAYtC,cAAc,qBAAqBK,YAAc,IACxEiC,EAAYtC,cAAc,oBAAoBK,YAC5CN,EAAQuC,EAAYtC,cAAc,cAGxCwC,GADIA,EAAaF,EAAYtC,cAAc,gBAChBwC,EAAWnC,aAIhCoC,EAAYH,EAAYtC,cAAc,sBAElC0C,EAAYD,EAAUE,aAAa,YACxB,KAAKC,KAAKF,KACjBnC,EAAKmC,EAAUV,MAAM,IACrBa,EAAcT,EAAIpC,cAAJ,qBAAgCO,EAAhC,UAEVuC,EAAOD,EAAYF,aAAa,gBACtC1C,EAAK,eAAW6C,EAAX,mBAA0BD,EAAYjC,aAMjD9B,EAAO,CAACE,UAASuD,OAAQA,EAAQxC,MAAOA,EAAMM,YAAamC,aAAYvC,SAE7EL,KAAKoB,KAAOoB,EAAIpC,cAAc,QAC9BJ,KAAKd,KAAOA,EAtFpB,UAuFgCD,EAAWC,GAvF3C,eAuFQc,KAAKf,WAvFb,yBAwFeC,GAxFf,kCAJA,IAAiB2C,IAIjB,uGA4FQ,OAAO7B,KAAKf,eA5FpB,KCDO,SAASkE,EAASD,EAAME,GAC3BC,SAASC,cAAc,IAAIC,YAAYL,EAAM,CAAEE,YAG5C,SAASI,IAAc,IAAD,uBAAPC,EAAO,yBAAPA,EAAO,gBACzB,MAAO,CACHC,GADG,SACCC,GACAF,EAAMG,SAAQ,SAAAV,GAAI,OAAIG,SAASQ,iBAAiBX,EAAMS,QCP3D,SAASG,IACZ,IAAMC,EAAYC,IAAMC,YA0BxB,OACI,6BACI,kBAAC,IAAD,CAAQC,UAAQ,EAACC,SAAO,EAACC,MAAO,CAACC,OAAQ,GAAIC,MAAO,GAAIC,QAAS,GAAIC,QAAS,kBAAMT,EAAUU,QAAQC,UAAtG,OACA,2BAAOxB,KAAK,OAAOvC,GAAG,gBAAgBgE,SA3B9C,SAAgBC,GACZ,IAAMC,EAAOD,EAAME,OAAOC,MAAM,GAC1BC,EAAS,IAAIC,WACnBD,EAAOnB,iBAAiB,OAAxB,uCAAgC,WAAMe,GAAN,mBAAAM,EAAA,sEAElBnF,EAAM6E,EAAME,OAAOK,OACnB7C,EAAS,IAAIxC,EAAUC,GAHL,SAILuC,EAAO8C,mBAJF,UAIlBlG,EAJkB,QAMpBoD,EAAO+C,eANa,uBAOpBC,EDjBc,qBCiB6B,CAACpG,SAPxB,iCAWxBoG,EDpBW,cCoByB,CAACpG,SAXb,UAYlBoD,EAAOiD,YAZW,QAaxBD,EDrBU,aCqByB,CAACpG,SAbZ,kDAexBsG,QAAQC,MAAM,qBAAd,MAfwB,0DAAhC,uDAkBAT,EAAOU,WAAWb,IAM0Cc,IAAK5B,K,OCpBlE,SAAS6B,EAASC,GAAQ,IAAD,EAEFC,mBAAS,IAFP,mBAErBC,EAFqB,KAEdC,EAFc,OAGJF,mBAAS,MAHL,mBAGrB5G,EAHqB,KAGf+G,EAHe,KAM5BX,EFnBuB,eEmBO5B,IAAG,SAAAkB,GAC7BqB,EAAQrB,EAAMxB,OAAOlE,SAEzBoG,EFrBsB,cEqBO5B,GAA7B,uCAAgC,WAAMkB,GAAN,SAAAM,EAAA,6DAC5Be,EAAQ,MADoB,KAE5BD,EAF4B,SAEbtG,IAFa,6EAAhC,uDAMAwG,qBAAU,WACN,sBAAC,sBAAAhB,EAAA,kEAAYc,EAAZ,SAA2BtG,IAA3B,sGAAD,KACD,IAKH,OACI,6BACI,kBAACoE,EAAD,MAA6B,6BAC7B,yBAAKnD,GAAG,QAEAzB,GACA,kBAAC,IAAD,CAAMZ,IAAKY,EAAKiB,MAAOgG,UAAU,WAC7B,kBAAC,IAAD,CAAWhG,MAAOjB,EAAKiB,MACZiG,SAAUlH,EAAKyD,OACf0D,OAAQ,kBAAC,IAAD,CAAQC,IAAKpH,EAAKmB,MAAOkG,KAAK,mBAEjD,kBAAC,IAAD,CAAaC,UAAQ,GACjB,kBAAC,IAAD,CAAQC,MAAI,GACR,yBAAKN,UAAU,mBAEnB,kBAAC,IAAD,CAAQM,MAAI,GAAZ,eAIJ,kBAAC,IAAD,CAAUC,YAAU,EAACC,UAAU,GAC1BzH,EAAK0D,aAKdmD,EAAM/D,KAAI,SAAA9C,GAAI,OACV,kBAAC,IAAD,CAAMZ,IAAKY,EAAKiB,OACZ,kBAAC,IAAD,CACIA,MAAOjB,EAAKiB,MACZiG,SAAUlH,EAAKyD,OACf0D,OAAQ,kBAAC,IAAD,CAAQC,IAAKpH,EAAKmB,MAAOkG,KAAK,mBAE1C,kBAAC,IAAD,CAAaC,UAAQ,GACjB,kBAAC,IAAD,CAAQC,MAAI,EAACjC,QAAS,kBAnCjC,SAAAtF,GAAI,OAAI2G,EAAMe,QAAQC,KAAd,gBAA4B3H,EAAKE,UAmCF0H,CAAS5H,KAArC,QACA,kBAAC,IAAD,CAAQuH,MAAI,GAAZ,WAEJ,kBAAC,IAAD,CAAUC,YAAU,GACfxH,EAAK0D,kB,2BCtE/B,SAASmE,EAAOlB,GACnB,IAAMjE,EAAOiE,EAAMmB,MAAMC,OAAOrF,KADN,EAEFkE,mBAAS,MAFP,mBAEnB5G,EAFmB,KAEb+G,EAFa,OAGUH,mBAAS,MAHnB,mBAGnBoB,EAHmB,KAGPC,EAHO,KAgB1B,OAXAjB,qBAAW,YN6CR,SAAiBtE,GACpB,OAAIvD,EACOA,EAAG+I,IAtDJ,QAsDexF,GAElBlD,EAASkB,MAAK,kBAAMvB,EAAG+I,IAxDpB,QAwD+BxF,OMhDrCyF,CAAQzF,GAAMhC,KAAKqG,GNmDpB,SAAwBrE,GAC3B,OAAIvD,EACOA,EAAGiJ,aA5DD,WA4DwB,SAAU1F,GAExClD,EAASkB,MAAK,kBAAMvB,EAAGiJ,aA9DjB,WA8DwC,SAAU1F,MMtD3D2F,CAAe3F,GAAMhC,KAAKuH,KAC3B,CAACvF,IAQA1C,EAEE,6BACI,6BACI,4BAAKA,EAAKiB,OACV,6BACI,6BAAK,yBAAKmG,IAAKpH,EAAKmB,MAAOmH,MAAM,OAAOC,IAAKvI,EAAKiB,QAASjB,EAAK0D,YAChE,6BACA,4BAAKsE,EAAW/G,UAO3B,2CCpBX,IAAMyG,EAAUc,cAEKC,E,kDACjB,aAAe,IAAD,8BACV,gBA4BJC,SAAW,SAACC,EAAMC,GAA6B,IAArBC,IAAoB,yDAC1C,EAAKC,UAAS,SAACC,GACX,IAAMC,EAASD,EAAMC,OAAO9F,QAE5B,OADA8F,EAAOrB,KAAK,CAACgB,OAAMC,WACZ,CAACI,SAAQH,gBAjCV,EAqCdI,aAAe,WAAO,IACND,EADK,YACK,EAAKD,MAAMC,QADhB,SAEjB,EAAKF,SAAS,CAACE,YAvCL,EA0CdE,QAAU,SAAC9J,EAAK+J,GACZ,EAAKC,SAAW,EAAKA,SAAStG,KAAI,SAACuG,GAC/B,OAAIA,EAAKC,QACED,EAGJ,2BAAIA,GAAX,IAAiB9J,OAAQ8J,EAAKjK,MAAQA,OAG1C,EAAK0J,SAAS,CAAC1J,MAAK+J,UAnDV,EAsDdI,KAAO,WACH,EAAKT,SAAS,CAACU,SAAS,EAAOC,WAAY,QAvDjC,EA0DdC,WAAa,WACT,EAAKZ,SAAS,CAACW,WAAYtF,SAASwF,eAAe,6BAvDnD,EAAKP,SAAWQ,EAAe9G,KAAI,SAACuG,GAChC,OAAIA,EAAKC,QACED,EAGJ,2BACAA,GADP,IAEI/D,QAAS,kBAAM,EAAK4D,QAAQG,EAAKjK,IAAKiK,EAAKhK,mBAInD,EAAK0J,MAAQ,CACTC,OAAQ,GACRS,WAAY,KACZD,SAAS,EACTpK,IAAKwK,EAAe,GAAGxK,IACvB+J,KAAMS,EAAe,GAAGvK,aAG5B+G,EJxC0B,sBIwCW5B,IAAG,SAAAkB,GACpC,IAAM1F,EAAO0F,EAAMxB,OAAOlE,KAC1B,EAAK0I,SAAL,gBAAuB1I,EAAKiB,MAAM4I,cAAlC,iCAzBM,E,qDA8DJ,IAAD,EACiC/I,KAAKiI,MAApCS,EADF,EACEA,QAASC,EADX,EACWA,WAAYT,EADvB,EACuBA,OAC5B,OACI,kBAAC,IAAD,CAAetB,QAASA,EAASoC,SAAU,eACvC,6BACI,kBAAC,IAAD,CACIrI,GAAG,yBACHsI,aAAW,yBACXP,QAASA,EACTQ,UAAQ,EACRC,cAAc,EACdC,OAAQpJ,KAAK4I,WACbS,OAAQrJ,KAAKyI,MACb,kBAAC,IAAD,CACIE,WAAYA,EACZL,SAAUtI,KAAKsI,SACfgB,iBAAkBC,IAAiBC,YAAYC,eAC/CC,iBAAkBH,IAAiBC,YAAYG,gBAC/CC,kBAAmBL,IAAiBC,YAAYG,gBAChDE,aAAa,aACbC,eAAgB,kBAAC,IAAD,CAAQC,MAAI,EAACvF,QAASxE,KAAKyI,MAA3B,SAChBuB,UAAU,oBACVC,cAAe,kBAAC,IAAD,aACfC,eAAgB,kBAAC,IAAD,mBAChBC,iBAAiB,WAEjB,kBAAC,IAAD,KACI,kBAAC,IAAD,CAAOC,KAAK,SAASC,UAAWzE,IAChC,kBAAC,IAAD,CAAOwE,KAAK,cAAcC,UAAWtD,IACrC,kBAAC,IAAD,CAAUuD,KAAK,IAAIC,GAAG,aAI9B,kBAAC,IAAD,CACI5J,GAAG,mBACHuH,OAAQA,EACRH,UAAU,EACVyC,UAAWxK,KAAKmI,aAChBsC,gBAAiB,a,GArGZC,iBCLbC,QACW,cAA7BrJ,OAAOsJ,SAASC,UAEe,UAA7BvJ,OAAOsJ,SAASC,UAEhBvJ,OAAOsJ,SAASC,SAAS7D,MACvB,2D,mBCXN8D,EAAcC,KAAK,CACfC,OAAQ,CACJC,SAAU,CAAC,yBAA0B,qBAK7CC,IAASC,OACP,kBAAC,EAAD,MACA9H,SAASwF,eAAe,SDmHpB,kBAAmBuC,WACrBA,UAAUC,cAAcC,MACrB1L,MAAK,SAAA2L,GACJA,EAAaC,gBAEdC,OAAM,SAAAhG,GACLD,QAAQC,MAAMA,EAAMiG,a","file":"static/js/main.b64b60e9.chunk.js","sourcesContent":["import {openDB} from 'idb';\n\nconst BOOKS = 'books';\nconst SECTIONS = 'sections';\nconst ELEMENTS = 'elements';\n\nlet db;\n\nconst openedDb = openDB('fb2-reader', 1, {\n    upgrade(db) {\n        // Create a store of objects\n        const books = db.createObjectStore(BOOKS, {\n            keyPath: 'hashHex', autoIncrement: true\n        });\n        books.createIndex('author', 'author');\n\n        const sections = db.createObjectStore(SECTIONS, {\n            keyPath: 'id', autoIncrement: true\n        });\n        sections.createIndex('parent', 'parent');\n\n        const elements = db.createObjectStore(ELEMENTS, {\n            keyPath: ['sectionId', 'ordinal']\n        });\n        elements.createIndex('sectionId', 'sectionId');\n\n    }\n});\n\nopenedDb.then(x => db = x);\n\nexport function addBook(book) {\n    return db.add(BOOKS, book);\n}\n\nexport function bookExists(book) {\n    return db.count(BOOKS, book.hashHex);\n}\n\nexport function addSection(section) {\n    return db.add(SECTIONS, section);\n}\n\nexport function addElement(element) {\n    return db.add(ELEMENTS, element);\n}\n\nexport function getAllBooks() {\n    if (db) {\n        return db.getAll(BOOKS);\n    }\n    return openedDb.then(() => db.getAll(BOOKS));\n}\n\nexport function getBook(hash) {\n    if (db) {\n        return db.get(BOOKS, hash);\n    }\n    return openedDb.then(() => db.get(BOOKS, hash));\n}\n\nexport function getRootSection(hash) {\n    if (db) {\n        return db.getFromIndex(SECTIONS, 'parent', hash);\n    }\n    return openedDb.then(() => db.getFromIndex(SECTIONS, 'parent', hash));\n}\n\nexport function getSections(parent) {\n    return db.getAllFromIndex(SECTIONS, 'parent', parent);\n}\n","import React from 'react';\nimport { FontIcon } from 'react-md';\n\nexport default [{\n  key: 'books',\n  primaryText: 'Books',\n  leftIcon: <FontIcon>book</FontIcon>,\n  active: true,\n}, {\n  key: 'read',\n  primaryText: 'Read',\n  leftIcon: <FontIcon>assignment</FontIcon>,\n},{\n  key: 'drafts',\n  primaryText: 'Drafts',\n  leftIcon: <FontIcon>drafts</FontIcon>,\n}, {\n  key: 'trash',\n  primaryText: 'Trash',\n  leftIcon: <FontIcon>delete</FontIcon>,\n}];\n","import {addSection, addElement, addBook, bookExists} from \"./db.js\";\n\nfunction buf2hex(buffer) { // buffer is an ArrayBuffer\n    return Array.prototype.map.call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2)).join('');\n}\n\nexport class Fb2Parser {\n    xml;\n    body;\n    book;\n    bookExists;\n\n    constructor(xml) {\n         this.xml = xml;\n         this.ordinal = 0;\n    }\n\n    async parseSection(section, parentSectionId) {\n        //  <p>, <image>, <poem>, <subtitle>, <cite>, <empty-line/>, <table>\n\n        const title = section.querySelector('title');\n        const image = section.querySelector('image');\n        const elements = section.querySelectorAll(':scope > *');\n\n        const id = await addSection({parent: parentSectionId, ordinal: this.ordinal++,\n            title: title?.textContent ?? null, image: image?.href ?? null });\n\n        for (const element of elements) {\n            if (element.tagName === 'section') {\n                await this.parseSection(element, id);\n            } else {\n                await addElement({\n                    tag: element.tagName,\n                    content: element.innerHTML,\n                    sectionId: id,\n                    ordinal: this.ordinal++\n                })\n            }\n        }\n    }\n\n    async parseBody() {\n        const bookId = await addBook(this.book);\n\n        // image, title, epigraph, section\n        const body = this.body;\n\n        const title = body.querySelector('title');\n        const image = body.querySelector('image');\n        const sections = body.querySelectorAll(':scope > section');\n\n        const id = await addSection({title: title?.textContent ?? null, image: image?.href ?? null,\n            ordinal: this.ordinal++, parent: bookId });\n        for (const section of sections) {\n            await this.parseSection(section, id);\n        }\n    }\n\n    async parseDescription() {\n        const hash = await window.crypto.subtle.digest(\"SHA-512\", new TextEncoder(\"utf-8\").encode(this.xml));\n        const hashHex = buf2hex(hash);\n\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(this.xml, \"application/xml\");\n        const description = doc.querySelector('description');\n\n        const author = description.querySelector('author first-name').textContent + ' ' +\n            description.querySelector('author last-name').textContent;\n        const title = description.querySelector('book-title');\n\n        let annotation = description.querySelector('annotation');\n        annotation = annotation && annotation.textContent;\n\n        // image\n        let image;\n        const imageInfo = description.querySelector('coverpage image');\n        if (imageInfo) {\n            const imageHref = imageInfo.getAttribute('l:href');\n            if (imageHref && /^#/.test(imageHref)) {\n                const id = imageHref.slice(1);\n                const imageBinary = doc.querySelector(`binary[id=\"${id}\"]`);\n                if (imageBinary) {\n                    const type = imageBinary.getAttribute('content-type');\n                    image = `data:${type};base64,${imageBinary.innerHTML}`;\n                }\n            }\n        }\n\n\n        const book = {hashHex, author: author, title: title.textContent, annotation, image};\n\n        this.body = doc.querySelector('body');\n        this.book = book;\n        this.bookExists = await bookExists(book);\n        return book;\n    }\n\n    get isAlreadyAdded() {\n        return this.bookExists;\n    }\n\n}\n\n","export const DB_READY = 'db-ready';\nexport const BOOK_ALREADY_ADDED = 'book-already-added';\nexport const BOOK_ADDING = 'book-adding';\nexport const BOOK_ADDED = 'book-added';\n\nexport function dispatch(type, detail) {\n    document.dispatchEvent(new CustomEvent(type, { detail }));\n}\n\nexport function on(...types) {\n    return {\n        do (subscription) {\n            types.forEach(type => document.addEventListener(type, subscription));\n        }\n    };\n}\n\n\n","import React from 'react';\r\nimport {Button} from \"react-md\";\r\nimport {Fb2Parser} from \"../fb2Parser\";\r\nimport * as Events from \"../events\";\r\n\r\nexport function BookImporter() {\r\n    const fileInput = React.createRef();\r\n\r\n    function change(event) {\r\n        const file = event.target.files[0];\r\n        const reader = new FileReader();\r\n        reader.addEventListener('load', async event => {\r\n            try {\r\n                const xml = event.target.result;\r\n                const parser = new Fb2Parser(xml);\r\n                const book = await parser.parseDescription();\r\n\r\n                if (parser.isAlreadyAdded) {\r\n                    Events.dispatch(Events.BOOK_ALREADY_ADDED, {book});\r\n                    return;\r\n                }\r\n\r\n                Events.dispatch(Events.BOOK_ADDING, {book});\r\n                await parser.parseBody();\r\n                Events.dispatch(Events.BOOK_ADDED, {book});\r\n            } catch (e) {\r\n                console.error('error when parsing', e);\r\n            }\r\n        });\r\n        reader.readAsText(file);\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <Button floating primary style={{height: 32, width: 32, padding: 6}} onClick={() => fileInput.current.click()}>add</Button>\r\n            <input type=\"file\" id=\"file-selector\" onChange={change} ref={fileInput}/>\r\n        </div>\r\n    );\r\n\r\n}\r\n","import React, {useEffect, useState} from 'react';\r\nimport {PureComponent} from \"react\";\r\nimport {getAllBooks} from \"../db\";\r\nimport {BookImporter} from \"./BookImporter\";\r\nimport * as Events from \"../events\";\r\nimport {\r\n    Avatar,\r\n    Button,\r\n    Card,\r\n    CardActions,\r\n    CardText,\r\n    CardTitle,\r\n} from 'react-md';\r\nimport './BookList.css';\r\n\r\nexport function BookList(props) {\r\n\r\n    const [books, setBooks] = useState([]);\r\n    const [book, setBook] = useState(null);\r\n\r\n\r\n    Events.on(Events.BOOK_ADDING).do(event => {\r\n        setBook(event.detail.book);\r\n    });\r\n    Events.on(Events.BOOK_ADDED).do(async event => {\r\n        setBook(null);\r\n        setBooks(await getAllBooks());\r\n    });\r\n\r\n\r\n    useEffect(() => {\r\n        (async () => setBooks(await getAllBooks()))();\r\n    }, []);\r\n\r\n\r\n    const readBook = book => props.history.push(`/read/${book.hashHex}`);\r\n\r\n    return (\r\n        <div>\r\n            <BookImporter></BookImporter><br/>\r\n            <div id=\"list\">\r\n                {\r\n                    book &&\r\n                    <Card key={book.title} className=\"loading\">\r\n                        <CardTitle title={book.title}\r\n                                   subtitle={book.author}\r\n                                   avatar={<Avatar src={book.image} role=\"presentation\"/>}\r\n                        />\r\n                        <CardActions expander>\r\n                            <Button flat>\r\n                                <div className=\"lds-dual-ring\"></div>\r\n                            </Button>\r\n                            <Button flat>\r\n                                Loading...\r\n                            </Button>\r\n                        </CardActions>\r\n                        <CardText expandable expanded={true}>\r\n                            {book.annotation}\r\n                        </CardText>\r\n                    </Card>\r\n                }\r\n                {\r\n                    books.map(book =>\r\n                        <Card key={book.title}>\r\n                            <CardTitle\r\n                                title={book.title}\r\n                                subtitle={book.author}\r\n                                avatar={<Avatar src={book.image} role=\"presentation\"/>}\r\n                            />\r\n                            <CardActions expander>\r\n                                <Button flat onClick={() => readBook(book)}>Read</Button>\r\n                                <Button flat>Delete</Button>\r\n                            </CardActions>\r\n                            <CardText expandable>\r\n                                {book.annotation}\r\n                            </CardText>\r\n                        </Card>\r\n                    )\r\n                }</div>\r\n        </div>\r\n    );\r\n}\r\n\r\n","import React, {useEffect, useMemo, useState} from 'react';\r\nimport {PureComponent} from \"react\";\r\nimport {getBook, getRootSection, getSections} from \"../db\";\r\n\r\nexport function Reader(props) {\r\n    const hash = props.match.params.hash;\r\n    const [book, setBook] = useState(null);\r\n    const [topSection, setTopSection] = useState(null);\r\n\r\n    useEffect( () => {\r\n        getBook(hash).then(setBook);\r\n        getRootSection(hash).then(setTopSection);\r\n    }, [hash])\r\n\r\n    // rendering algo\r\n    // get first non-section element - draw: sections and element\r\n    // get next sibling if there is - draw - intersection observer\r\n    // ..\r\n    // when no next sibling\r\n\r\n    if (book) {\r\n        return (\r\n          <div>\r\n              <div>\r\n                  <h2>{book.title}</h2>\r\n                  <div>\r\n                      <div><img src={book.image} align=\"left\" alt={book.title}/>{book.annotation}</div>\r\n                      <br/>\r\n                      <h3>{topSection.title}</h3>\r\n                  </div>\r\n              </div>\r\n          </div>\r\n        )\r\n    }\r\n\r\n    return <div>loading...</div>\r\n}\r\n","/* eslint-disable react/no-array-index-key */\nimport React, {PureComponent} from 'react';\nimport './App.css';\nimport {Button, DialogContainer, FontIcon, NavigationDrawer, Snackbar} from 'react-md';\nimport inboxListItems from './constants/inboxListItems';\nimport {BookList} from './components/BookList';\nimport * as Events from \"./events\";\n\n\nimport {BrowserRouter, Redirect, Route, Switch} from \"react-router-dom\";\n\nimport {createBrowserHistory} from 'history';\nimport {Reader} from \"./components/Reader\";\n\n// создаём кастомную историю\nconst history = createBrowserHistory();\n\nexport default class App extends PureComponent {\n    constructor() {\n        super();\n\n        // Update the items so they have an onClick handler to change the current page\n        this.navItems = inboxListItems.map((item) => {\n            if (item.divider) {\n                return item;\n            }\n\n            return {\n                ...item,\n                onClick: () => this.setPage(item.key, item.primaryText),\n            };\n        });\n\n        this.state = {\n            toasts: [],\n            renderNode: null,\n            visible: true,\n            key: inboxListItems[0].key,\n            page: inboxListItems[0].primaryText,\n        };\n\n        Events.on(Events.BOOK_ALREADY_ADDED).do(event => {\n            const book = event.detail.book;\n            this.addToast(`Book \"${book.title.toUpperCase()}\" has been added earlier!`);\n        });\n    }\n\n    addToast = (text, action, autohide = true) => {\n        this.setState((state) => {\n            const toasts = state.toasts.slice();\n            toasts.push({text, action});\n            return {toasts, autohide};\n        });\n    }\n\n    dismissToast = () => {\n        const [, ...toasts] = this.state.toasts;\n        this.setState({toasts});\n    };\n\n    setPage = (key, page) => {\n        this.navItems = this.navItems.map((item) => {\n            if (item.divider) {\n                return item;\n            }\n\n            return {...item, active: item.key === key};\n        });\n\n        this.setState({key, page});\n    };\n\n    hide = () => {\n        this.setState({visible: false, renderNode: null});\n    };\n\n    handleShow = () => {\n        this.setState({renderNode: document.getElementById('navigation-drawer-demo')});\n    };\n\n    render() {\n        const {visible, renderNode, toasts} = this.state;\n        return (\n            <BrowserRouter history={history} basename={'/fb2-reader'}>\n                <div>\n                    <DialogContainer\n                        id=\"navigation-drawer-demo\"\n                        aria-label=\"Navigation Drawer Demo\"\n                        visible={visible}\n                        fullPage\n                        focusOnMount={false}\n                        onShow={this.handleShow}\n                        onHide={this.hide}>\n                        <NavigationDrawer\n                            renderNode={renderNode}\n                            navItems={this.navItems}\n                            mobileDrawerType={NavigationDrawer.DrawerTypes.TEMPORARY_MINI}\n                            tabletDrawerType={NavigationDrawer.DrawerTypes.PERSISTENT_MINI}\n                            desktopDrawerType={NavigationDrawer.DrawerTypes.PERSISTENT_MINI}\n                            toolbarTitle=\"FB2 Reader\"\n                            toolbarActions={<Button icon onClick={this.hide}>close</Button>}\n                            contentId=\"main-demo-content\"\n                            temporaryIcon={<FontIcon>menu</FontIcon>}\n                            persistentIcon={<FontIcon>arrow_back</FontIcon>}\n                            contentClassName=\"md-grid\">\n\n                            <Switch>\n                                <Route path='/books' component={BookList}/>\n                                <Route path='/read/:hash' component={Reader}/>\n                                <Redirect from='/' to='/books'/>\n                            </Switch>\n\n                        </NavigationDrawer>\n                        <Snackbar\n                            id=\"example-snackbar\"\n                            toasts={toasts}\n                            autohide={true}\n                            onDismiss={this.dismissToast}\n                            autohideTimeout={4000}\n                        />\n                    </DialogContainer>\n                </div>\n            </BrowserRouter>\n        );\n    }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport WebFontLoader from 'webfontloader';\n\nWebFontLoader.load({\n    google: {\n        families: ['Roboto:300,400,500,700', 'Material Icons'],\n    },\n});\n\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}